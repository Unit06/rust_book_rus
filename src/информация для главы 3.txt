Формула перевода Фаренгейта (°F) в Цельсий (°C) и наоборот Цельсия (°C) в Фаренгейт (°F):

(Фаренгейт — 32) : 1,8 = Цельсий Пример: (50°F - 32) : 1,8 = 10°C
Цельсий х 1,8 + 32 = Фаренгейт Пример: 10°C x 1,8 + 32 = 50°F

-------------------------------------

Числа Фибоначчи — бесконечная числовая последовательность , в которой каждое число есть сумма двух предыдущих: . F n = F n − 1 + F n − 2 .

Статья:  https://habr.com/ru/post/261159/
Динамическое программирование

После решения с запоминанием становится понятно, что нам нужны не все предыдущие результаты, а только два последних.
Кроме этого, вместо того, чтобы начинать с fib(n) и идти назад, можно начать с fib(0) и идти вперёд. У следующего кода
линейное время выполнение, а использование памяти – фиксированное. На практике скорость решения будет ещё выше,
поскольку тут отсутствуют рекурсивные вызовы функций и связанная с этим работа. И код выглядит проще.

Это решение часто приводится в качестве примера динамического программирования.

def fib(n):
    a = 0
    b = 1
    for __ in range(n):
        a, b = b, a + b
    return a


Хорошее: Быстро работает для малых n, простой код
Плохое: Всё ещё линейное время выполнения
Злое: Да особо ничего.

Так же более сложное в реализации, но наиболее правильное по скорости и использовании памяти решение - использование
матричной алгебры:

Я организовал рекурсивную реализацию pow, поскольку её проще понять. Итеративную версию смотрите тут.
----------------------------------код на питоне
def pow(x, n, I, mult):
    """
    Возвращает x в степени n. Предполагает, что I – это единичная матрица, которая
    перемножается с mult, а n – положительное целое
    """
    if n == 0:
        return I
    elif n == 1:
        return x
    else:
        y = pow(x, n // 2, I, mult)
        y = mult(y, y)
        if n % 2:
            y = mult(x, y)
        return y


def identity_matrix(n):
    """Возвращает единичную матрицу n на n"""
    r = list(range(n))
    return [[1 if i == j else 0 for i in r] for j in r]


def matrix_multiply(A, B):
    BT = list(zip(*B))
    return [[sum(a * b
                 for a, b in zip(row_a, col_b))
            for col_b in BT]
            for row_a in A]


def fib(n):
    F = pow([[1, 1], [1, 0]], n, identity_matrix(2), matrix_multiply)
    return F[0][1]
----------------------------------

Хорошее: Фиксированный объём памяти, логарифмическое время
Плохое: Код посложнее
Злое: Приходится работать с матрицами, хотя они не так уж и плохи